<!DOCTYPE html>
<html lang="en">

<head>
  <title>DK: Grid surface</title>
</head>

<body>

<h1><a href="index.html">Dmitry Kurtaev/</a> C++: Grid surface</h1>
<p>
<b>Problem:</b> drawing surface using heights map.<br>
<b>Example:</b> written on C++, freeglut.<br>
<b>Languages:</b>
<a href="grid_surface.html">EN</a>,
<a href="grid_surface_ru.html">RU</a>
</p>

<p>
Let we have function z = f(x, y) which defines surface in (x, y, z) space.
Nodes (x, y) from uniform grid. z is height for each node.
</p>

<h2>Table of contents</h2>
&bull; <a href="#coords_axises">Coordinate axises</a><br>
&bull; <a href="#surface_definition">Surface definition</a><br>
&bull; <a href="#surface_via_spheres">Surface via spheres</a><br>
&bull; <a href="#surface_via_triangles">Surface via triangles</a><br>
&bull; <a href="#normals_computation">Normals computation</a><br>
&bull; <a href="#indices_drawing">Drawing by indices</a><br>
&bull; <a href="#strip_drawing">Drawing by triangle strip</a><br>

<h2 id="coords_axises">Coordinate axises</h2>
<p>
Initially we write program with coordinate axises drawing.<br>
Plane of (x, y) points is horizontal base, by z axis values of surface function.<br>
</p>

<table>
  <td width="50%" valign="top">
    <script src="code_samples/grid_surface_draw_axises.cpp"></script>
  </td>

  <td width="50%" valign="top">
    <img src="images/grid_surface_coord_axises.png" alt="Coordinate axises"><br>
  </td>
</table>

<h2 id="surface_definition">Surface definition</h2>
<table>
  <td width="50%" valign="top">
  <pre><code>
     ^ y
  y3 |   *-----*-----*-----*-----*  min_x = x0; max_x = x4
     |   |     |     |     |     |  min_y = y0; max_y = y3
     |   |     |     |     |     |  n_nodes_by_x = 5
     |   |     |     |     |     |  n_nodes_by_y = 4
  y2 |   *-----*-----*-----*-----*
     |   |     |     |     |     |
     |   |     |     |     |     |
     |   |     |     |     |     |
  y1 |   *-----*-----*-----*-----*
     |   |     |     |     |     |
     |   |     |     |     |     |
     |   |     |     |     |     |
  y0 |   *-----*-----*-----*-----*
     +-------------------------------> x
         x0    x1    x2    x3    x4
  </code></pre></td>

  <td width="50%" valign="top">
  <pre><code>
                                         ^ z
                                         |
                                         |
                 f(x3, y1)               |
                @              f(x1, y0) |
                |              @         |
                |              |         |
             x4 |  x3    x2    | x1  x0  |
       x <------|--------------|---------+
             *--|--*-----*-----*-----*  / y0
            /   | /     /     /     /  /
           /    |/     / @ f(x1, y2)  /
          *-----*-----*--|--*-----*  / y1
         /     /     /   | /     /  /
        /     /     /    |/     /  /
       *-----*-----*-----*-----*  / y2
      /     /     /     /     /  /
     /     /     /     /     /  /
    *-----*-----*-----*-----*  / y3
                            y v
    </code></pre></td>
</table>

<p>
Define surface as set of points (x, y, z) where (x, y) are nodes of uniform
grid. Grid called as uniform when distance between neighboring nodes along each
axis is constant.<br>

In every node we knows z as function of (x, y): z = f(x, y). We call it
value as height. Set of heights we call as heights map.
</p>

<h2 id="surface_via_spheres">Surface via spheres</h2>
<p>
Let's build some surface using f(x, y) function. At the start our surface is a
set of small spheres.
</p>

<table>
  <tr>
    <td valign="top">
      <script src="code_samples/grid_surface_via_spheres_header.cpp"></script>
    </td>

    <td valign="top">
      <img src="images/grid_surface_via_spheres.png" alt="Surface via spheres"><br>
    </td>
  </tr>

  <tr>
    <td valign="top">
      <script src="code_samples/grid_surface_via_spheres_constructor.cpp"></script>
    </td>

    <td valign="top">
      <script src="code_samples/grid_surface_via_spheres_draw.cpp"></script>
    </td>
  </tr>
</table>

<h2 id="surface_via_triangles">Surface via triangles</h2>
<p>
For filling empty space among nodes we need to draw OpenGL's primitives with
vertices on nodes. Split cells of grid by triangles.<br>
Now we need to change drawing function only due all vertices data stored at
corresponding array.
</p>

<table>
  <td valign="top">
  <pre><code>
     ^ y
  y3 |   *-----*-----*-----*-----*
     |   |   / |   / |   / |   / |
     |   |  /  |  /  |  /  |  /  |
     |   | /   | /   | /   | /   |
  y2 |   *-----*-----*-----*-----*
     |   |   / |   / |   / |   / |
     |   |  /  |  /  |  /  |  /  |
     |   | /   | /   | /   | /   |
  y1 |   *-----*-----*-----*-----*
     |   |   / |   / |   / |   / |
     |   |  /  |  /  |  /  |  /  |
     |   | /   | /   | /   | /   |
  y0 |   *-----*-----*-----*-----*
     +-------------------------------> x
         x0    x1    x2    x3    x4
  </code></pre></td>

  <td valign="top">
  <pre><code>
  (x,y+dy) ____top____(x+dx,y+dy)
          |  <--     /|
          | |   ^   / |
          | v   |  /  |
         l|  -->  /   |r
         e|      /    |i
         f|     /     |g
         t|    / <--  |h
          |   / |   ^ |t
          |  /  V   | |
          | /    -->  |
          |/__________|
      (x,y)  bottom (x+dx,y)
    </code></pre></td>
</table>

<table>
  <td valign="top">
    <script src="code_samples/grid_surface_via_triangles_draw.cpp"></script>
  </td>

  <td valign="top">
    <img src="images/grid_surface_via_triangles.png" alt="Surface via triangles"><br>
  </td>
</table>

<h2 id="normals_computation">Normals computation</h2>
<p>
For robust shading our surface set normals to it for every vertex.
</p>

<pre><code>
                  ^ normal
(x2, y2, z2) _____|____
             \    |   / (x1, y1, z1)
              \   |  /
               \    /
                \  /
                 \/ (x3, y3, z3)
</code></pre>

<p>
For triangles with vertices (x1, y1, z1), (x2, y2, z2), (x3, y3, z3),
in counter-clockwise, normal is a vector (nx, ny, nz):
</p>

<pre><code>
nx = y1 * (z2 - z3) + y2 * (z3 - z1) + y3 * (z1 - z2)
ny = x1 * (z3 - z2) + x2 * (z1 - z3) + x3 * (z2 - z1)
nz = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)
</code></pre>

<p>
For each internal vertex (node of which not on top, left, bottom or right border
of grid) computing normal as mean of normals for triangles includes this vertex.
<br>
Boundary normals may be copyied from neighboring layer of internal vertices.
</p>

<pre><code>
^                               1) nx = dy*(z1-z0); ny = dx*(z2-z1); nz = dx*dy;
|                               2) nx = dy*(z2-z3); ny = dx*(z3-z0); nz = dx*dy;
y+dy   ______z6_____z5          3) nx = dy*(z0-z4); ny = dx*(z3-z0); nz = dx*dy;
|     |****/ |    / |           4) nx = dy*(z0-z4); ny = dx*(z4-z5); nz = dx*dy;
|     |***/  | 5 /  |           5) nx = dy*(z6-z5); ny = dx*(z0-z6); nz = dx*dy;
|     |**/   |  /   |           6) nx = dy*(z1-z0); ny = dx*(z0-z6); nz = dx*dy;
|     |*/  6 | /  4 |
y     z1-----z0-----z4
|     |  1 / |  3 /*|
|     |   /  |   /**|     nx = 1/6 * dy * (2 * z1 + z2 - z3 - 2 * z4 - z5 + z6)
|     |  / 2 |  /***|     ny = 1/6 * dx * (-z1 + z2 + 2 * z3 + z4 - z5 - 2 * z6)
|     | /    | /****|     nz = dx * dy
y-dy  z2-----z3-----*
|
+--- x-dx -- x --- x+dx ---->
</code></pre>

<table>
  <td valign="top">
    <script src="code_samples/grid_surface_normals_constructor_internal_vertices.cpp"></script>
  </td>

  <td valign="top">
    <script src="code_samples/grid_surface_normals_constructor_border_vertices.cpp"></script>
    <pre><code>
      #####  ##  ##  ##     ######   ###
     ###    ######  ##     ##  ##   ##
    #####  ##  ##  #####  ######   *
    </code></pre>
  </td>
</table>

<table>
  <tr>
    <td valign="top" rowspan="2">
      <script src="code_samples/grid_surface_normals_draw.cpp"></script>
    </td>

    <td valign="top">
      <script src="code_samples/grid_surface_settings.cpp"></script>
    </td>
  </tr>

  <tr>
    <td valign="top">
      <img src="images/grid_surface_lighting.png" alt="S"><br>
    </td>
  </tr>
</table>

<h2 id="indices_drawing">Drawing by indices</h2>
<p>
Useful to use OpenGL usage with drawing primitives not by explit calls of
glVertex and glNormal but via indices of corresponding vertices at our arrays.
</p>

<table>
  <td valign="top">
    <script src="code_samples/grid_surface_indices_constructor.cpp"></script>
  </td>

  <td valign="top">
    <script src="code_samples/grid_surface_indices_draw.cpp"></script>
  </td>
</table>

<h2 id="strip_drawing">Drawing by triangle strip</h2>
<p>
Using certain indices order we can more efficiently draw triangles which forms
strip. It is directly our case because all grid could be divided by strips.
</p>

<pre><code>
0_____2_____4_____6         GL_TRIANGLES: 1, 2, 0, 1, 3, 2, 3, 4, 2, 3, 5, 4,
|    /|    /|    /|                       5, 6, 4, 5, 7, 6
|  /  |  /  |  /  |         GL_TRIANGLE_STRIP: 0, 1, 2, 3, 4, 5, 6, 7
|/____|/____|/____|
1     3     5     7
</code></pre>

<p>
Least it gives us less number of stored indices. But more profit achieves due
OpenGL use our tip about generic vertices. For us it decreasing time of frame
drawing.
</p>

<p>
During jump between strips we changing indexing direction (from right to left
and from bottom to top or vice versa). We can understand it via imaging grid
as single folded strip:
</p>

<pre><code>
8_____9_____10____11   indices: 4, 0, 5, 1, 6, 2, 7, 3, 7, 11, 6, 10, 5, 9, 4, 8
|    /|    /|    /|
|  /  |  /  |  /  |
|/____|/____|/____|
4    /5    /6    /7
|  /  |  /  |  /  |
|/____|/____|/____|
0     1     2     3
                           /\
                          / |\
                         /  | \
           .------      /\  | / 8
          /            / |\ |/
         /            /  | \/
        \/           /\  | / 9
                    / |\ |/
4_____5_____6_____7/  | \/
|    /|    /|    /|\  | / 10
|  /  |  /  |  /  | \ |/
|/____|/____|/____|  \/
0     1     2     3   11
</code></pre>


<table>
  <td valign="top">
    <script src="code_samples/grid_surface_strip_constructor.cpp"></script>
  </td>

  <td valign="top">
    <script src="code_samples/grid_surface_strip_draw.cpp"></script>
  </td>
</table>

<p>
If comparing number of frames per second using code snippets from this page,
we can demonstrating advantages of each approach.<br>
(For estimation drawing 100 surfaces simultaneously, grids is 100x100,
surfaces from similar function, with different scales along (x, y). Code from
examples not optimized thus values from table below are approximated. Each
number is accumulated during 5 seconds).
<pre><code>
+---------------+-------------------+
| Method        | Frames per second |
+---------------+-------------------+
| via triangles | 9                 |
| by indices    | 38-40             |
| by strip      | 59                |
+----------------+------------------+
</code></pre>
</p>

</body>

</html>
