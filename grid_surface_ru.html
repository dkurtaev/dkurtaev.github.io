<!DOCTYPE html>
<html lang="ru">

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<head>
  <title>DK: Heights map</title>
</head>

<body>

<h1><a href="index_ru.html">Dmitry Kurtaev/</a> C++: Grid surface using heights map</h1>
<p>
<b>Задача:</b> изображение трёхмерной поверхности, заданной на сетке.<br>
<b>Пример:</b> с использованием C++, freeglut.<br>
<b>Языки:</b>
<a href="grid_surface_ru.html">RU</a>
</p>

<p>
Пусть в пространстве (x, y, z) задана сеточная функция: узлы в плоскости (x, y)
и значения высот (координат z) для каждого из узлов.
</p>

<h2>Главы</h2>
&bull; <a href="#coords_axises">Подготовка</a><br>
&bull; <a href="#surface_definition">Задание поверхности</a><br>
&bull; <a href="#surface_via_spheres">Поверхность как множество точек</a><br>
&bull; <a href="#surface_via_triangles">Триангуляция</a><br>
&bull; <a href="#normals_computation">Вычисление нормалей</a><br>
&bull; <a href="#indices_drawing">Использование индексов</a><br>
&bull; <a href="#strip_drawing">Лента треугольников</a><br>

<h2 id="coords_axises">Подготовка</h2>
<p>
Сделаем основание для будущей работы: отобразим координатные оси.<br>
Для ориентации в трехмерном пространстве, отобразим координатные оси.
Плоскость координат (x, y) будем считать осонованием, а по оси координат z
откладывать значения функции, задающей поверхность.<br>
Перед началом рисования, необходимо задать положение камеры в пространстве.
<!-- Изображение камеры, с осью -->
</p>

<table>
  <td width="50%" valign="top">
    <script src="code_samples/grid_surface_draw_axises.cpp"></script>
  </td>

  <td width="50%" valign="top">
    <img src="images/grid_surface_coord_axises.png" alt="Coordinate axises"><br>
  </td>
</table>

<h2 id="surface_definition">Задание поверхности</h2>
<table>
  <td width="50%" valign="top">
  <pre><code>
     ^ y
  y3 |   *-----*-----*-----*-----*  min_x = x0; max_x = x4
     |   |     |     |     |     |  min_y = y0; max_y = y3
     |   |     |     |     |     |  n_nodes_by_x = 5
     |   |     |     |     |     |  n_nodes_by_y = 4
  y2 |   *-----*-----*-----*-----*
     |   |     |     |     |     |
     |   |     |     |     |     |
     |   |     |     |     |     |
  y1 |   *-----*-----*-----*-----*
     |   |     |     |     |     |
     |   |     |     |     |     |
     |   |     |     |     |     |
  y0 |   *-----*-----*-----*-----*
     +-------------------------------> x
         x0    x1    x2    x3    x4
  </code></pre></td>

  <td width="50%" valign="top">
  <pre><code>
                                         ^ z
                                         |
                                         |
                 f(x3, y1)               |
                @              f(x1, y0) |
                |              @         |
                |              |         |
             x4 |  x3    x2    | x1  x0  |
       x <------|--------------|---------+
             *--|--*-----*-----*-----*  / y0
            /   | /     /     /     /  /
           /    |/     / @ f(x1, y2)  /
          *-----*-----*--|--*-----*  / y1
         /     /     /   | /     /  /
        /     /     /    |/     /  /
       *-----*-----*-----*-----*  / y2
      /     /     /     /     /  /
     /     /     /     /     /  /
    *-----*-----*-----*-----*  / y3
                            y v
    </code></pre></td>
</table>

<p>
Для описания поверхности как множества точек пространства (x, y, z), зададим
равномерную сетку в плоскости (x, y). Сетка называется равномерной, если
расстояние между соседними узлами, вдоль каждой из осей, не изменяется.<br>
В каждом из узлов известна координата z как функция от (x, y): z = f(x, y).
Будем называть это значение высотой. Множество значений высот для всех узлов
сетки будем называть картой высот.
</p>

<h2 id="surface_via_spheres">Поверхность как множество точек</h2>
<p>
Создадим некоторую поверхность по известному закону f(x, y). Для начала,
изобразим точки поверхности сферами.
</p>

<table>
  <tr>
    <td valign="top">
      <script src="code_samples/grid_surface_via_spheres_header.cpp"></script>
    </td>

    <td valign="top">
      <img src="images/grid_surface_via_spheres.png" alt="Surface via spheres"><br>
    </td>
  </tr>

  <tr>
    <td valign="top">
      <script src="code_samples/grid_surface_via_spheres_constructor.cpp"></script>
    </td>

    <td valign="top">
      <script src="code_samples/grid_surface_via_spheres_draw.cpp"></script>
    </td>
  </tr>
</table>

<h2 id="surface_via_triangles">Триангуляция</h2>
<p>
Для рисования сплошной поверхности, необходимо осуществить рисование примитивов
с вершинами в узлах сетки. Разобьём пространство между вершинами на
треугольники.<br>
Поскольку вся необходимая информация содержится в массиве с координатами,
изменяем только функцию отрисовки.
</p>

<table>
  <td valign="top">
  <pre><code>
     ^ y
  y3 |   *-----*-----*-----*-----*
     |   |   / |   / |   / |   / |
     |   |  /  |  /  |  /  |  /  |
     |   | /   | /   | /   | /   |
  y2 |   *-----*-----*-----*-----*
     |   |   / |   / |   / |   / |
     |   |  /  |  /  |  /  |  /  |
     |   | /   | /   | /   | /   |
  y1 |   *-----*-----*-----*-----*
     |   |   / |   / |   / |   / |
     |   |  /  |  /  |  /  |  /  |
     |   | /   | /   | /   | /   |
  y0 |   *-----*-----*-----*-----*
     +-------------------------------> x
         x0    x1    x2    x3    x4
  </code></pre></td>

  <td valign="top">
  <pre><code>
  (x,y+dy) ____top____(x+dx,y+dy)
          |  <--     /|
          | |   ^   / |
          | v   |  /  |
         l|  -->  /   |r
         e|      /    |i
         f|     /     |g
         t|    / <--  |h
          |   / |   ^ |t
          |  /  V   | |
          | /    -->  |
          |/__________|
      (x,y)  bottom (x+dx,y)
    </code></pre></td>
</table>

<table>
  <td valign="top">
    <script src="code_samples/grid_surface_via_triangles_draw.cpp"></script>
  </td>

  <td valign="top">
    <img src="images/grid_surface_via_triangles.png" alt="Surface via triangles"><br>
  </td>
</table>

<h2 id="normals_computation">Вычисление нормалей</h2>
<p>
Для создания теней необходимо задать нормаль к поверхности в каждой из вершин.
</p>

<pre><code>
                  ^ normal
(x2, y2, z2) _____|____
             \    |   / (x1, y1, z1)
              \   |  /
               \    /
                \  /
                 \/ (x3, y3, z3)
</code></pre>

<p>
Для треугольника с вершинами (x1, y1, z1), (x2, y2, z2), (x3, y3, z3),
перечисленными против часовой стрелки, нормалью является вектор (nx, ny, nz):
</p>

<pre><code>
nx = y1 * (z2 - z3) + y2 * (z3 - z1) + y3 * (z1 - z2)
ny = x1 * (z3 - z2) + x2 * (z1 - z3) + x3 * (z2 - z1)
nz = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)
</code></pre>

<p>
Для каждой внутренней вершины (узел которой не принадлежит верхней, левой,
нижней или правой границе сетки) вычислим нормаль как среднее между нормалями
треугольников, содержащих эту вершину.<br>
Для граничных вершин, нормали могут быть скопированы с соседнего слоя внутренних
вершин.
</p>

<pre><code>
^                               1) nx = dy*(z1-z0); ny = dx*(z2-z1); nz = dx*dy;
|                               2) nx = dy*(z2-z3); ny = dx*(z3-z0); nz = dx*dy;
y+dy   ______z6_____z5          3) nx = dy*(z0-z4); ny = dx*(z3-z0); nz = dx*dy;
|     |****/ |    / |           4) nx = dy*(z0-z4); ny = dx*(z4-z5); nz = dx*dy;
|     |***/  | 5 /  |           5) nx = dy*(z6-z5); ny = dx*(z0-z6); nz = dx*dy;
|     |**/   |  /   |           6) nx = dy*(z1-z0); ny = dx*(z0-z6); nz = dx*dy;
|     |*/  6 | /  4 |
y     z1-----z0-----z4
|     |  1 / |  3 /*|
|     |   /  |   /**|     nx = 1/6 * dy * (2 * z1 + z2 - z3 - 2 * z4 - z5 + z6)
|     |  / 2 |  /***|     ny = 1/6 * dx * (-z1 + z2 + 2 * z3 + z4 - z5 - 2 * z6)
|     | /    | /****|     nz = dx * dy
y-dy  z2-----z3-----*
|
+--- x-dx -- x --- x+dx ---->
</code></pre>

<table>
  <td valign="top">
    <script src="code_samples/grid_surface_normals_constructor_internal_vertices.cpp"></script>
  </td>

  <td valign="top">
    <script src="code_samples/grid_surface_normals_constructor_border_vertices.cpp"></script>
    <pre><code>
      #####  ##  ##  ##     ######   ###
     ###    ######  ##     ##  ##   ##
    #####  ##  ##  #####  ######   *
    </code></pre>
  </td>
</table>

<table>
  <tr>
    <td valign="top" rowspan="2">
      <script src="code_samples/grid_surface_normals_draw.cpp"></script>
    </td>

    <td valign="top">
      <script src="code_samples/grid_surface_settings.cpp"></script>
    </td>
  </tr>

  <tr>
    <td valign="top">
      <img src="images/grid_surface_lighting.png" alt="S"><br>
    </td>
  </tr>
</table>

<h2 id="indices_drawing">Использование индексов</h2>
<p>
Удобно воспользоваться функционалом OpenGL, позволяющим производить рисование
примитивов, указывая индексы вершин внутри наших массивов, вместо явных
вызовов glVertex и glNormal.
</p>

<table>
  <td valign="top">
    <script src="code_samples/grid_surface_indices_constructor.cpp"></script>
  </td>

  <td valign="top">
    <script src="code_samples/grid_surface_indices_draw.cpp"></script>
  </td>
</table>

<h2 id="strip_drawing">Лента треугольников</h2>
<p>
Используя особый порядок индексов, можно более эффективно осуществить рисование
треугольников, образующих ленту (strip), что подходит для нашей задачи: вся
сетка может быть разделена на ленты.
</p>

<pre><code>
0_____2_____4_____6         GL_TRIANGLES: 1, 2, 0, 1, 3, 2, 3, 4, 2, 3, 5, 4,
|    /|    /|    /|                       5, 6, 4, 5, 7, 6
|  /  |  /  |  /  |         GL_TRIANGLE_STRIP: 0, 1, 2, 3, 4, 5, 6, 7
|/____|/____|/____|
1     3     5     7
</code></pre>

<p>
Как минимум, это позволяет сэкономить на памяти, выделяемой под хранение
индексов. Но главное, что информация, которую мы сообщаем OpenGL об
образовании данной конструкции, помогает использовать специализированные методы.
Для нас это означает уменьшение времени, требуемого для отрисовки кадра.
</p>

<p>
При переходе между лентами, меняется направление индексации (справа налево,
снизу вверх). Можно понять этот момент, представив сетку в виде единой,
сложенной ленты:
</p>

<pre><code>
8_____9_____10____11   indices: 4, 0, 5, 1, 6, 2, 7, 3, 7, 11, 6, 10, 5, 9, 4, 8
|    /|    /|    /|
|  /  |  /  |  /  |
|/____|/____|/____|
4    /5    /6    /7
|  /  |  /  |  /  |
|/____|/____|/____|
0     1     2     3
                           /\
                          / |\
                         /  | \
           .------      /\  | / 8
          /            / |\ |/
         /            /  | \/
        \/           /\  | / 9
                    / |\ |/
4_____5_____6_____7/  | \/
|    /|    /|    /|\  | / 10
|  /  |  /  |  /  | \ |/
|/____|/____|/____|  \/
0     1     2     3   11
</code></pre>


<table>
  <td valign="top">
    <script src="code_samples/grid_surface_strip_constructor.cpp"></script>
  </td>

  <td valign="top">
    <script src="code_samples/grid_surface_strip_draw.cpp"></script>
  </td>
</table>

<p>
Если сравнить количество кадров в секунду, используя код из примеров, получится
наглядно продемонстрировать преимущества каждого из подходов:<br>
(Для оценки производилась одновременная отрисовка 100 поверхностей, точки
которых заданы одной функцией. Использовались сетки 100x100, все поверхности
на одном уровне, случайного размера. Код, представленный в примерах, не является
оптимальным, поэтому значения, представленные в таблице, носят лишь
оценочный характер. Количество кадров аккумулированно с периодом в 5 секунд.).
<pre><code>
+----------------+-------------------+
| Метод          | Кадров в секунду  |
+----------------+-------------------+
| Триангуляция   | 9                 |
| Индексирование | 38-40             |
| Ленты          | 59                |
+----------------+-------------------+
</code></pre>
</p>

</body>

</html>
